using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using VulnerabilityPrediction.Formatting;

namespace VulnerabilityPrediction.Calculations
{
    public class ClassificationTree
    {
        private Node rootNode;

        public ClassificationTree()
        {

            var lowUserNode = new Range(0, .45);
            var medUserNode = new Range(.45, .8);
            var aboveLowUserNode = new Range(.45, 1);
            var highUserNode = new Range(.8, 1);

            var lowSeverNode = new Node(0, .5);
            lowSeverNode.AddLeaf(lowUserNode, Classification.Low);
            lowSeverNode.AddLeaf(aboveLowUserNode, Classification.Guarded);

            var medSeverNode = new Node(.5, .8);
            medSeverNode.AddLeaf(lowUserNode, Classification.Guarded);
            medSeverNode.AddLeaf(medUserNode, Classification.Elevated);
            medSeverNode.AddLeaf(highUserNode, Classification.High);


            var highSeverNode = new Node(.8, 1);
            highSeverNode.AddLeaf(lowUserNode, Classification.High);
            highSeverNode.AddLeaf(aboveLowUserNode, Classification.Severe);

            rootNode = new Node();
            rootNode.AddLeaf(lowSeverNode);
            rootNode.AddLeaf(medSeverNode);
            rootNode.AddLeaf(highSeverNode);

        }
        public static double GetValue(Classification toGet)
        {
            switch(toGet){
                case Classification.Low: return 0.1;
                case Classification.Guarded: return 0.3;
                case Classification.Elevated: return 0.5;
                case Classification.High: return 0.7;
                default: return 0.9;
            }
        }
        public static Classification GetClass(double value)
        {
            if (value <= 0.2)
                return Classification.Low;
            else if (value > 0.2 && value <= 0.4)
                return Classification.Guarded;
            else if (value > 0.4 && value <= 0.6)
                return Classification.Elevated;
            else if (value > 0.6 && value <= 0.8)
                return Classification.High;
            else
                return Classification.Severe;
        }

        public Classification Classify(Exploit classify)
        {
            return rootNode.Traverse(classify);
        }

    }
    class Node
    {
        private List<Node> leafNodes;

        public Range Range{get; private set;}

        private Classification risk;
        public Node() { leafNodes = new List<Node>(); }
        public Node(double lower, double upper)
        {
            leafNodes = new List<Node>();
            Range = new Range();
            Range.Lower = lower;
            Range.Upper = upper;
        }

        public Node(Classification risk)
        {
            this.risk = risk;
        }

        public Node(Range range, Classification risk)
        {
            leafNodes = new List<Node>();
            this.risk = risk;
            this.Range = range;
        }
        public void AddLeaf(Range leafRange, Classification risk)
        {
            leafNodes.Add(new Node(leafRange, risk));
        }

        public void AddLeaf(Node leaf)
        {
            leafNodes.Add(leaf);
        }

        public Classification Traverse(Exploit ex)
        {
            return Traverse(ex, ex.Type);
        }

        public Classification Traverse()
        {
            return risk;
        }
        public Classification Traverse(Exploit ex, PlatformType type)
        {
            foreach (var leaf in leafNodes)
            {
                if (leaf.InRange(ex.PercentAffected))
                    return leaf.Traverse();
            }
            throw new Exception("No valid range, please check the construction of your tree");
        }

        public Classification Traverse(Exploit ex, ExploitType type)
        {
            foreach (var leaf in leafNodes)
            {
                if (leaf.InRange(ex.Severity))
                    return leaf.Traverse(ex, ex.Platform);
            }
            throw new Exception("No valid range, please check the construction of your tree");
        }

        private bool InRange(double toCheck)
        {
            return Range.InRange(toCheck);
        }




    }

    class Range{
        public Range() { }

        public Range(double lower, double upper)
        {
            this.Lower = lower;
            this.Upper = upper;
        }
        public double Lower { get; set; }
        public double Upper { get; set; }

        public bool InRange(double toCheck)
        {
            return toCheck > Lower && toCheck <= Upper;
        }
    }
    public enum Classification
    {
        Low,
        Guarded,
        Elevated,
        High,
        Severe

        
    }
}
