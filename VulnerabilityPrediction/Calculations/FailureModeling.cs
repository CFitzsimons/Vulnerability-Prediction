using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using VulnerabilityPrediction.Formatting;

namespace VulnerabilityPrediction.Calculations
{
    class FailureModeling
    {
        private const int MAX_DAYS = 7;
        private const int MIN_YEAR = 2010;

        DateTime cutoff;
        
        public FailureModeling()
        {
            cutoff = DateTime.Now.AddDays(MAX_DAYS);
        }

        public FailureModeling(DateTime cutoff)
        {
            this.cutoff = cutoff; 
        }
        public DateTime? CalcNextBreakdown(List<Exploit> history)
        {
            DateTime earliest = DateTime.Now;
            DateTime mostRecent = new DateTime(MIN_YEAR - 1, 1, 1);
            int totalFailures = 0;
            if (history.Count == 0 || history.OrderBy(t => t.DateReleased).Last().DateReleased.Year < MIN_YEAR)
                return null;
            foreach (var exploitEvent in history.Where(t => t.DateReleased.Year >= MIN_YEAR))
            {
                if (exploitEvent.DateReleased > mostRecent)
                    mostRecent = exploitEvent.DateReleased;
                if (earliest > exploitEvent.DateReleased)
                    earliest = exploitEvent.DateReleased;
                totalFailures++;
            }
            int totalDays = (int)mostRecent.Subtract(earliest).TotalDays;
            if (totalDays == 0)
                return null;
            var x = (double)totalFailures / totalDays;
            return mostRecent.AddDays(1 / x);

        }
        public void GenerateToCutoff(List<Exploit> history)
        {
            DateTime? next;
            do
            {
                next = CalcNextBreakdown(history);
                if (next == null)
                    break;
                var latest = history.OrderBy(t => t.DateReleased).Last();
                DateTime nonNull = (DateTime) next;
                Exploit tmpExploit = new Exploit(-1, nonNull, "Fake Exploit", "Fake Exploit", 
                    latest.Type, latest.Platform, latest.PortNumber, latest.PercentAffected, latest.Reliability, latest.Severity);
                tmpExploit.Degrade();
                history.Add(tmpExploit);
            } while (next < cutoff);

            
        }

        public double ProbabilityOfFailure(DateTime day, List<Exploit> history)
        {
            DateTime mostRecent = new DateTime(MIN_YEAR - 1, 1, 1);
            int totalFailures = 0;
            foreach (var exploitEvent in history.Where(t => t.DateReleased.Year >= MIN_YEAR))
            {
                if (exploitEvent.DateReleased > mostRecent)
                    mostRecent = exploitEvent.DateReleased;
                totalFailures++;
            }
            double failuresPerDay = (DateTime.Today.Year - MIN_YEAR) * 365;
            failuresPerDay += DateTime.Today.DayOfYear;
            Console.WriteLine("Number of days: " + failuresPerDay);
            Console.WriteLine("Number of Failures: " + totalFailures);
            Console.WriteLine("Latest Failure: " + mostRecent);
            failuresPerDay = totalFailures / failuresPerDay;

            int numDays = day.DayOfYear - mostRecent.DayOfYear;
            double total = failuresPerDay;
            for (int i = 0; i < numDays; i++)
            {
                total *= 1 - failuresPerDay;
            }

            return total;
        }
    }
}
